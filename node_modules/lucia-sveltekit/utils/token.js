import cookie from "cookie";
import jwt from "jsonwebtoken";
import { verify, Encrypter } from "./crypto.js";
import { LuciaError } from "./error.js";
class Token {
    constructor(value, secret, cookieOptions) {
        this.value = value || "";
        this.secret = secret;
        this.cookie = () => {
            return cookie.serialize(cookieOptions.name, this.value, {
                secure: cookieOptions.secure,
                path: cookieOptions.path,
                maxAge: cookieOptions.max_age,
                httpOnly: true,
                sameSite: "lax",
            });
        };
    }
}
export class AccessToken extends Token {
    constructor(value, context) {
        super(value, context.secret, {
            name: "access_token",
            path: "/",
            max_age: 60 * 15,
            secure: context.env === "PROD",
        });
        this.user = async (fingerprintToken) => {
            try {
                const userSession = jwt.decode(this.value);
                const isValid = await verify(fingerprintToken, userSession.fingerprint_hash || "");
                if (!isValid)
                    throw new Error();
                if (userSession.role !== "access_token")
                    throw new Error();
                delete userSession.fingerprint_hash;
                delete userSession.exp, delete userSession.iat;
                delete userSession.role;
                const user = userSession;
                return user;
            }
            catch {
                throw new LuciaError("AUTH_INVALID_ACCESS_TOKEN");
            }
        };
    }
}
export class FingerprintToken extends Token {
    constructor(value, context) {
        super(value, context.secret, {
            name: "fingerprint_token",
            path: "/",
            max_age: 60 * 60 * 24 * 365,
            secure: context.env === "PROD",
        });
    }
}
export class RefreshToken extends Token {
    constructor(value, context) {
        super(value, context.secret, {
            name: "refresh_token",
            path: "/",
            max_age: 0,
            secure: context.env === "PROD",
        });
        this.encrypt = () => {
            try {
                const encryptedValue = this.encrypter.encrypt(this.value);
                return new EncryptedRefreshToken(encryptedValue, this.context);
            }
            catch {
                return new EncryptedRefreshToken("", this.context);
            }
        };
        this.userId = async (fingerprint) => {
            try {
                const userSession = jwt.decode(this.value);
                const isValid = await verify(fingerprint, userSession.fingerprint_hash || "");
                if (!isValid)
                    throw new Error();
                if (userSession.role !== "refresh_token")
                    throw new Error();
                return userSession.user_id;
            }
            catch (e) {
                throw new LuciaError("AUTH_INVALID_REFRESH_TOKEN");
            }
        };
        this.context = context;
        this.encrypter = new Encrypter(this.context.secret);
    }
}
export class EncryptedRefreshToken extends Token {
    constructor(value, context) {
        super(value, context.secret, {
            name: "encrypt_refresh_token",
            path: "/",
            max_age: 60 * 60 * 24 * 365,
            secure: context.env === "PROD",
        });
        this.decrypt = () => {
            const decryptedValue = this.encrypter.decrypt(this.value);
            return new RefreshToken(decryptedValue, this.context);
        };
        this.context = context;
        this.encrypter = new Encrypter(this.context.secret);
    }
}
